在维护集合最值的操作上，堆是一种简单、易懂、且非常高效的数据结构

经典的堆问题：蚂蚁问题
假设现在有一个水平面，上面有 8 只蚂蚁排成一排。方便起见，我们给所有的蚂蚁从左到右依次编号，编号为 1 到 8。从 0 秒开始，红色蚂蚁向左爬，蓝色蚂蚁向右爬，爬行的速度都是 1m/s。如果有 2 只蚂蚁迎面碰到以后，这 2 只蚂蚁不会做任何的感情交流，而会立刻掉头向相反方向继续爬行。而爬行到桌子边沿的蚂蚁，会从桌子上掉下去。问：有哪些蚂蚁会从左边掉下去，又有哪些蚂蚁会从右边掉下去？
我们要找到当前时刻距离最近的两只相向而行的蚂蚁。那在一堆距离数据中，每次找到一个最小的距离，这不就是小顶堆的经典应用场景吗？因此，解决这个问题的关键，就是使用小顶堆来存储当前桌面上所有相向而行的蚂蚁之间的距离。
理解堆中的数据是不可以动态更新的，所以我们要将两只蚂蚁在 0 时刻的逻辑距离存储到堆中
核心就在于用堆来维护蚂蚁之间相撞的顺序。

堆就是一种具有特殊性质的完全二叉树
完全二叉树是由满二叉树去掉最后一层右侧的若干节点而形成的二叉树结构
完全二叉树有一个很优秀的性质，就是可以被存储在一片连续的数组空间中
父节点编号与子节点编号之间的关系就会发现，如果父节点编号是 i，其左孩子的编号就是 2 * i，右孩子的编号就是 2 * i + 1

一棵完全二叉树可以对应到一段连续的数组空间，而根据数组空间的内容，我们也可以唯一地还原成一棵完全二叉树

在计算机中，我们会把数组作为完全二叉树的实际存储结构，而完全二叉树，则是我们重新看待这段数组信息的思维逻辑结构。因此，数据结构最大的价值，就是对我们思维逻辑结构的改造。

堆结构的定义
分为两类，小顶堆和大顶堆
如果在一棵完全二叉树中，每个父节点的值都要小于其两个子节点的值，我们就管这种结构叫做小顶堆。相对应地，大顶堆就是每个父节点的值要大于其两个子节点的值。

根据小顶堆的性质定义，我们可以轻松得知，小顶堆中的最小值一定放在了根节点，也就是存储在数组中的第一个位置。如果我们将数组中的所有元素看成一个集合的话，那小顶堆的作用就非常明显了，就是维护这个集合中的最小值。

数据结构 = 结构定义 + 结构操作。结构定义和结构操作是组成数据结构最重要的两个部分，也是你之后在学任何一种数据结构时的重点内容。结构定义就是定义一种性质，结构操作就是维护这种性质。

堆这种结构支持的两种最基本的结构操作：插入新元素和删除最值元素。

先牢牢记住一点：堆的实际存储结构是数组，这个数组是一段从下标 1 开始的连续存储空间

堆的插入操作
可以将这个新的元素，放置到整个数组的最后一位。对应到完全二叉树的思维逻辑结构中，就是向树中的最后一层添加了一个新的叶节点
这一步的操作叫做元素放置
这一步叫做向上调整，它的原理就是在当前元素值小于其父节点值的时候，交换子节点与父节点值的位置，就这样一直向上调整，直到当前节点大于父节点的值或者调整到了堆顶。

堆的删除最值操作
堆的删除操作是有局限性的
第一步要做的就是元素覆盖，也就是用堆的最后一位元素，覆盖掉堆顶元素。
调整的方法其实也很简单，就是从堆顶位置开始，每次从当前元素所在三元组中找到一个最小值，与当前元素交换。交换后，让当前位置的元素继续和下面两个元素比较，如果这个三元组中依然有最小值，那我们就继续向下调整，直到当前元素是三元组中的最小值为止。

堆实际的存储结构和结构操作。之前我们说过，它其实就是一个数组，在插入元素时，从数组的末尾放入元素，而删除元素时，是从数组的头部移出元素

堆是实现优先队列的其中一种方式，优先队列每次出队的元素，都是队列中优先级最大的值。

堆是用来维护集合最值的高效数据结构

----------------------
线程池
基于完全二叉树的二叉堆从逻辑上我们可以看成是一个优先队列。之所以叫优先队列，是因为其对外的行为表现像极了一个队列：头部出队、尾部入队，而且，每次出队的时候，都是将优先级最高的任务弹出队列。

理解线程和进程的基础概念
要想封装一个线程池，首先你得了解什么是线程（Thread），以及与线程相关的另一个概念进程（Process）。如果你之前对进程和线程有一点了解，也可以借着这个机会进行复习巩固。

线程是操作系统进行运算调度的基本单元，进程是操作系统进行资源分配的最基本单元。

说到计算调度，我们就必须要说说 CPU 时间片。
CPU 在给程序提供计算能力的时候，不是等到第一个程序执行完了，才执行第二个程序，而是先给第一个程序提供一小段时间的计算能力，再给第二个程序提供一小段时间的计算能力。如果我们站在 100 个程序一端，就会感觉 CPU 同时在运行着 100 个程序，而实际上 CPU 在同一时间只为 1 个程序服务。因此，分时系统就是指多个程序依据时间来共享硬件或者软件资源。

那么 CPU 为程序提供服务的一小段时间，其实就是一个时间片。更准确点来说，CPU 在一个时间片里运行的不是程序而是线程。

那当递归深度过深发生爆栈情况时，爆的就是这个线程栈。这也就是为什么，我们不建议在函数内部申请过大的数组空间。因为过大的数组空间，很有可能把这个只有 8M 大小的栈区挤爆。
一个线程其实不仅仅代表了一份计算资源，还绑定了一个存储局部变量的存储区。所以，之前我们所写的 C/C++ 程序，实际上是单线程的程序。当我们的程序想要申请更多的线程资源的时候，可以像申请更多的内存空间一样，使用系统中提供的方法进行申请
