树的结构十分直观，而树的很多概念定义都有一个相同的特点：递归，也就是说，一棵树要满足某种性质，往往要求每个节点都必须满足。例如，在定义一棵二叉搜索树时，每个节点也都必须是一棵二叉搜索树。

树的形状有：普通二叉树、平衡二叉树、完全二叉树、二叉搜索树、四叉树（Quadtree）、多叉树（N-ary Tree）。
树是由结点和边组成的，不存在环的一种数据结构。

1. 前序遍历（Preorder Traversal）
根左右

应用场景：运用最多的场合包括在树里进行搜索以及创建一棵新的树。

2. 中序遍历（Inorder Traversal）
左根右

应用场景：最常见的是二叉搜索树，由于二叉搜索树的性质就是左孩子小于根节点，根节点小于右孩子，对二叉搜索树进行中序遍历的时候，被访问到的节点大小是按顺序进行的。

3. 后序遍历（Postorder Traversal）
左右根

应用场景：在对某个节点进行分析的时候，需要来自左子树和右子树的信息。收集信息的操作是从树的底部不断地往上进行，好比你在修剪一棵树的叶子，修剪的方法是从外面不断地往根部将叶子一片片地修剪掉。

LeetCode 第 250 题
LeetCode 第 230 题

在二叉树中，每个结点最多有两个分支，即每个结点最多有两个子结点，分别称作左子结点和右子结点。

在二叉树中，有下面两个特殊的类型:
满二叉树，定义为除了叶子结点外，所有结点都有 2 个子结点。

完全二叉树，定义为除了最后一层以外，其他层的结点个数都达到最大，并且最后一层的叶子结点都靠左排列。

完全二叉树看上去并不完全，但为什么这样称呼它呢？这其实和二叉树的存储有关系。存储二叉树有两种办法，一种是基于指针的链式存储法，另一种是基于数组的顺序存储法。

链式存储法，也就是像链表一样，每个结点有三个字段，一个存储数据，另外两个分别存放指向左右子结点的指针
顺序存储法，就是按照规律把结点存放在数组里,根据这种存储方法，我们可以发现如果结点 X 的下标为 i，那么 X 的左子结点总是存放在 2 * i 的位置，X 的右子结点总是存放在 2 * i + 1 的位置。

之所以称为完全二叉树，是从存储空间利用效率的视角来看的。对于一棵完全二叉树而言，仅仅浪费了下标为 0 的存储位置。而如果是一棵非完全二叉树，则会浪费大量的存储空间。

遍历一棵树，有非常经典的三种方法，分别是前序遍历、中序遍历、后序遍历。这里的序指的是父结点的遍历顺序，前序就是先遍历父结点，中序就是中间遍历父结点，后序就是最后遍历父结点。不管哪种遍历，都是通过递归调用完成的
前序遍历，对树中的任意结点来说，先打印这个结点，然后前序遍历它的左子树，最后前序遍历它的右子树。
中序遍历，对树中的任意结点来说，先中序遍历它的左子树，然后打印这个结点，最后中序遍历它的右子树。
后序遍历，对树中的任意结点来说，先后序遍历它的左子树，然后后序遍历它的右子树，最后打印它本身。

对于没有任何特殊性质的二叉树而言，抛开遍历的时间复杂度以外，真正执行增加和删除操作的时间复杂度是 O(1)。树数据的查找操作和链表一样，都需要遍历每一个数据去判断，所以时间复杂度是 O(n)。

二叉查找树（也称作二叉搜索树）具备以下几个的特性：
在二叉查找树中的任意一个结点，其左子树中的每个结点的值，都要小于这个结点的值。
在二叉查找树中的任意一个结点，其右子树中每个结点的值，都要大于这个结点的值。
在二叉查找树中，会尽可能规避两个结点数值相等的情况。
对二叉查找树进行中序遍历，就可以输出一个从小到大的有序数据队列。

在利用二叉查找树执行查找操作时，我们可以进行以下判断(这样的“二分查找”所消耗的时间复杂度就可以降低为 O(logn))：
首先判断根结点是否等于要查找的数据，如果是就返回。
如果根结点大于要查找的数据，就在左子树中递归执行查找动作，直到叶子结点。
如果根结点小于要查找的数据，就在右子树中递归执行查找动作，直到叶子结点。

二叉查找树的插入操作
在二叉查找树执行插入操作也很简单。从根结点开始，如果要插入的数据比根结点的数据大，且根结点的右子结点不为空，则在根结点的右子树中继续尝试执行插入操作。直到找到为空的子结点执行插入动作。
二叉查找树插入数据的时间复杂度是 O(logn)。但这并不意味着它比普通二叉树要复杂。原因在于这里的时间复杂度更多是消耗在了遍历数据去找到查找位置上，真正执行插入动作的时间复杂度仍然是 O(1)。

二叉查找树的删除操作会比较复杂，这是因为删除完某个结点后的树，仍然要满足二叉查找树的性质。
情况一，如果要删除的结点是某个叶子结点，则直接删除，将其父结点指针指向 null 即可。
情况二，如果要删除的结点只有一个子结点，只需要将其父结点指向的子结点的指针换成其子结点的指针即可。
情况三，如果要删除的结点有两个子结点，则有两种可行的操作方式。
    第一种，找到这个结点的左子树中最大的结点，替换要删除的结点。
    第二种，找到这个结点的右子树中最小的结点，替换要删除的结点。

树是多个结点的有限集
根结点
空树
子树

树的度是树内各结点度的最大值

树中结点的最大层次称为树的深度或高度

若将树中结点的各子树看成是从左至右是有次序的，不能互换的，称为有序树，反之为无序树

森林是m棵互不相交的树的集合

树的存储结构：
1、双亲表示法
除了根结点外，其余每个结点不一定有子结点，但一定有且仅有一个双亲
每个结点包含数据域和指针域

2、孩子表示法
一个数据域 多个指针域 一个存储指针域个数的度域

3、孩子兄弟表示法

二叉树：
n个结点的有限集合，该集合或者为空集，或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树的二叉树组成

度最大为2.严格区分左右子树

斜树：左斜树和右斜树（线性表结构可以理解为是树的一种极其特殊的表现形式）

满二叉树：所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上

完全二叉树：满二叉树一定是完全二叉树，反之不然
按层序编号

二叉树的性质：
1、在二叉树的第i层上至多有2^(ⅰ-1) 个结点（i >= 1）
2、深度为k的二叉树至多有2^k - 1 个结点（k >= 1）
3、对任何一棵二叉树T，如果其终端结点数为n、0，度为2的结点数为n、2，则n、0=n、2+1
结点总数n = n、0 + n、1 + n、2  连接线总数 = n - 1 = n、1 + 2*n、2，至此推导出n、0=n、2+1
4、具有n个结点的完全二叉树的深度为(log2'n) + 1
5、如果一棵树有n个结点的完全二叉树的结点按层序编号，i=1无双亲，i>1双亲结点为i/2；2i>n，则无左孩子，否则左孩子是结点2i;2i+1>n，无右孩子，否则右孩子是结点2i+1

二叉树的存储结构：
1、顺序存储结构是用一维数组存储二叉树中的结点，并且结点的存储位置使用数组下标但要能体现相互之间的逻辑关系。但需要注意的是顺序存储结构一般只用于完全二叉树，如果是个右斜树那得浪费很多空间。

2、二叉链表
二叉树的每个结点最多有两个孩子，故为它设计一个数据域和两个指针域  lChild | data | rChild

二叉树遍历
指从根结点出发，按照某种次序依次访问二叉树中所有结点，使得每个结点被访问一次且仅被访问一次

二叉树遍历方法
前序遍历
中序遍历
后续遍历