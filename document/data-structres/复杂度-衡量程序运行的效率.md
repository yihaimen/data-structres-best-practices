使用数据结构的知识，构建算法思维

复杂度是衡量代码运行效率的重要的度量因素。

怎么衡量复杂度
首先，这段代码消耗的资源是什么：消耗计算时间和计算空间 - 时间复杂度和空间复杂度

其次，这段代码对于资源的消耗是多少：
通常会关注时间或者空间消耗量与输入数据量之间的关系。

如何去计算复杂度
复杂度是一个关于输入数据量 n 的函数

O(n) 表示的是，复杂度与计算实例的个数 n 线性相关；O(logn) 表示的是，复杂度与计算实例的个数 n 对数相关

复杂度的计算方法遵循以下几个原则：
例如 O(n) 和 O(2n) 表示的是同样的复杂度。我们详细分析下，O(2n) 等于 O(n+n)，也等于 O(n) + O(n)。也就是说，一段 O(n) 复杂度的代码只是先后执行两遍 O(n)，其复杂度是一致的。

其次，多项式级的复杂度相加的时候，选择高者作为结果，例如 O(n²)+O(n) 和 O(n²) 表示的是同样的复杂度。具体分析一下就是，O(n²)+O(n) = O(n²+n)。随着 n 越来越大，二阶多项式的变化率是要比一阶多项式更大的

O(1) 也是表示一个特殊复杂度，含义为某个任务通过有限可数的资源即可完成。此处有限可数的具体意义是，与输入数据量 n 无关。

时间复杂度与代码结构的关系
时间复杂度与代码的结构有着非常紧密的关系；而空间复杂度与数据结构的设计有关

一些经验性的结论
一个顺序结构的代码，时间复杂度是 O(1)。
二分查找，或者更通用地说是采用分而治之的二分策略，时间复杂度都是 O(logn)。
一个简单的 for 循环，时间复杂度是 O(n)。
两个顺序执行的 for 循环，时间复杂度是 O(n)+O(n)=O(2n)，其实也是 O(n)。
两个嵌套的 for 循环，时间复杂度是 O(n²)

代码效率优化就是要将可行解提高到更优解，最终目标是：要采用尽可能低的时间复杂度和空间复杂度，去完成一段代码的开发。

数据结构：将“昂贵”的时间复杂度转换成“廉价”的空间复杂度

为了降低复杂度，一个直观的思路是：梳理程序，看其流程中是否有无效的计算或者无效的存储
常用的降低时间复杂度的方法有递归、二分法、排序算法、动态规划等
而降低空间复杂度的方法，就要围绕数据结构做文章

降低空间复杂度的核心思路就是，能用低复杂度的数据结构能解决问题，就千万不要用高复杂度的数据结构。

第一步，暴力解法。在没有任何时间、空间约束下，完成代码任务的开发。
第二步，无效操作处理。将代码中的无效计算、无效存储剔除，降低时间或空间复杂度。
第三步，时空转换。设计合理数据结构，完成时间复杂度向空间复杂度的转移。

增删查：掌握数据处理的基本操作,以不变应万变
设计合理的数据结构，以达到降低时间损耗的目的。

常用的分析方法可以参考下面的 3 个步骤,构成了设计合理数据结构的方法论：
首先，这段代码对数据进行了哪些操作？
其次，这些操作中，哪个操作最影响效率，对时间复杂度的损耗最大？
最后，哪种数据结构最能帮助你提高数据操作的使用效率？

两个方面来对数据进行查找操作：
根据元素的位置或索引来查找
根据元素的数值特征来查找

数据处理的基本操作只有 3 个，分别是增、删、查。其中，增和删又可以细分为在数据结构中间的增和删，以及在数据结构最后的增和删。区别就在于原数据的位置是否发生改变。查找又可以细分为按照位置条件的查找和按照数据数值特征的查找。几乎所有的数据处理，都是这些基本操作的组合和叠加。

如何完成线性表结构下的增删查？
线性表是 n 个数据元素的有限序列，最常用的是链式表达，通常也叫作线性链表或者链表

在链表中存储的数据元素也叫作结点，一个结点存储的就是一条数据记录。每个结点的结构包括两个部分：
第一是具体的数据值；
第二是指向下一个结点的指针。

在链表的最前面，通常会有个头指针用来指向第一个结点。对于链表的最后一个结点，由于在它之后没有下一个结点，因此它的指针是个空指针。

对于一个单向链表，让最后一个元素的指针指向第一个元素，就得到了循环链表；

把结点的结构进行改造，除了有指向下一个结点的指针以外，再增加一个指向上一个结点的指针。这样就得到了双向链表。

还可以对双向链表和循环链表进行融合，就得到了双向循环链表

链表在新增、删除数据都比较容易，可以在 O(1) 的时间复杂度内完成。但对于查找，不管是按照位置的查找还是按照数值条件的查找，都需要对全部数据进行遍历。这显然就是 O(n) 的时间复杂度。

虽然链表在新增和删除数据上有优势，但仔细思考就会发现，这个优势并不实用。这主要是因为，在新增数据时，通常会伴随一个查找的动作。

线性表真正的价值在于，它对数据的存储方式是按照顺序的存储。如果数据的元素个数不确定，且需要经常进行数据的新增和删除时，那么链表会比较合适。如果数据元素大小确定，删除插入的操作并不多，那么数组可能更适合些。