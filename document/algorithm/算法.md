算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。
简单说就是解决问题的方法。

基本特性：
输入：0个或多个输入
输出：至少一个或多个输出 ~ 没有输出的算法不用也罢……
有穷性：不会出现死循环的情况，且其运行时间是可接受的 ~ 寻求最优解
确定性：每个步骤都是确定的，不会出现二义性 ~ 符合纯函数
可行性：每一步都能通过执行有限次数完成，其能够在计算机上运行

算法设计的要求：
1、正确性：能够正常的走完 happy path，也能优雅的解决 error path
2、可读性：代码是写成人看的，其次是给机器看的，谁都不想继承祖传代码……
3、健壮性：具有很好的容错能力
4、时间效率高和存储量低：花最少的钱获得最大的收益

算法效率的度量方法：
1、事后统计法：不推荐 ~ 因为需要事先根据算法设计出测试程序和数据，费事费力且依赖计算机本身性能和测试数据的规模
2、事前分析估算法：通过统计方法进行估算
主要因素有：
算法采用的策略 ~ 最优解 ~ 根本
编译产生的代码质量 ~ 编译软件
问题的输入规模 ~ 数据规模 ~ 数据越大，差距越明显
机器执行指令的速度 ~ 机器性能

函数的渐进增长：
随着n的增大，fn 的执行次数 小于 gn 的执行次数。通常我们可以忽略加法常数，还可忽略最高次项相乘的常数，只需关注其指数。~ 这也是事前估算法的论理依据。

算法时间复杂度：
语句总的执行次数 T(n) 与 问题规模 n 的关系，用大 O 记法。
常见的有：O(1) 常数阶 、 O(n) 线性阶 、 O(n^2) 平方阶、 O(n^3) 立方阶 、 O(log n) 对数阶 、 O(2^n) 指数阶、 O(nlog n) nlog n阶 等
所耗时间从小到大：
O(1) < O(log n) < O(n) < O(nlog n) < O(n^2) < O(n^3) < O(2^n)

推导大 O 阶方法：
1、用常数1取代运行时间中的所有加法常数
2、在修改后的运行次数函数中，只保留最高阶项
3、若最高阶项存在且不是1，则去除与其相乘的常数

算法空间复杂度：
语句所占空间 S(n) 与 问题规模 n 的关系 ~ 但通常我们只讲时间复杂度
