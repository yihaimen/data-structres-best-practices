## 1、快速排序
核心思想：找准基准值的位置（一般以头部元素为基准）；然后将小于它的放在前面，大于它的放在后面（partition操作）；对左右两侧递归这个过程。
当选择首位为基准值时，应先从末尾往前查找，再从前往后查找。若为末尾，则反之。

时间复杂度：取决于递归的深度，借助二叉树的结构进行分析。首次partition的操作执行了n次，总的为T(n) = T(l) + T(r)。在最优的情况下O(nlogn)，最差的时候为O(n^2)；

题外话：
直接插入排序->希尔排序（插入类）
简单选择排序->堆排序（选择类）
冒泡排序->快速排序（交换类）

快速排序是通过不断比较和移动交换来实现排序的，区别冒泡在于增大了记录的比较和移动距离，将大于基准值的从前面放在后面，将小于基准值的从后边移到前面，从而减少了总的比较次数和移动交换次数。可由于它的比较和交换是跳跃进行的，因此它是一种不稳定的排序算法。

### 优化：
* 单边递归
* 基准值三点定位
  取三个数先进行排序，然后取中间的作为基准值。一般是首尾和中间的数。虽然可以用随机数生成器去取，但这也会带来时间上的开销，所以不建议。这种方法对小数组很有效，但对大数组来说，也很费时，不过我们可以使用九数取中。
* partition 减少交换

## 2、堆排序
